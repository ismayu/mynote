### 编译链接过程

预编译：

删除#define,展开所有宏定义

处理条件编译指令，`#if,#ifdef,#elif,#else,#endif`

处理`#include`，递归的展开所有头文件

删除注释

添加行号信息

保留`#pragma`编译器指令，编译器要使用

.i文件

编译：

词法分析->将源文件分割成对应的记号(关键字，标识符之类的)

语法分析->运算符号的优先级和含义确定(括号不匹配，缺少操作符)

语义分析->静态语义分析(声明，类型匹配，类型转换)

优化->源代码优化(2+6优化成8，优化变量的使用)，代码生成，目标代码优化(生成汇编语言)，此时变量的地址尚未确定(变量如果和源代码处于同一模块中编译器此时可以给变量分配空间确定他们的地址)

.s文件

汇编：

将汇编代码转为机器码

.o文件

链接：

符号解析->将每个符号引用和定义相关联，每个符号对应的是函数，全局变量，静态变量 

重定位->编译器和汇编器从0地址开始代码(.text)和数据节(.data)，链接器将每个符号和对应的内存地址相关联从而重新定位这些节，修改所有对这些符号的引用，使得他们指向对应的内存。

编译器和汇编器生成可重定位目标文件(包括共享目标文件，elf文件),链接器生成可执行目标文件



### C++相关

构造函数不能成为虚函数原因：

- 虚函数是通过虚函数表来查找的，而虚函数表是由类的实例化对象的vptr指针指向，虚指针存在于对象的内部空间需要调用构造函数初始化。若构造函数为虚函数则需要去找vptr，但此时vptr还未初始化

- 虚函数是为了实现多态，在运行时才能明确调用对象，根据传入的对象类型来调用函数

析构函数可以成为虚函数的原因：

- 类发生了继承且类中有虚函数，析构函数必须为虚函数，否则可能会发生内存泄漏

  delete基类指针会导致派生类内存泄漏

成为虚函数的条件：1.函数可取地址2.依赖对象调用

**静多态、动多态**

动多态的派生类中的函数地址是在运行期间由寄存器给到虚函数表的

动多态发生条件：1.指针或者引用调用虚函数2.对象完整

**static关键字：**

静态成员变量(面向对象)：

- 该变量为所有对象所共有，在data区分配内存，不占用对象内存。
- 既不是在声明类的时候分配内存也不是在创建对象时分配内存，而是初始化的时候已经分配好内存且必须在类外进行初始化，否则编译过链接不通过。
- 静态数据成员遵循public，protected，private访问规则

静态成员函数(面向对象)：

- 静态成员函数仅能访问静态成员变量和静态成员函数，不能访问非静态成员变量和函数
- 非静态成员函数可以访问静态成员函数和静态成员变量

静态全局变量(面向过程)：

- 变量在.data区分配内存
- 未初始化的静态全局变量会被程序初始化为0
- 静态全局变量在声明它的整个文件可见，文件外不可见

静态局部变量(面向过程)：

- 变量在.data区分配内存
- 程序执行到该对象的声明处被首次初始化，若未初始化则会被默认初始化为0
- 静态局部变量始终驻留在.data区，直到程序结束，但作用域为局部作用域。

静态函数(面向过程)：

- 静态函数不能被其他文件所用
- 其他文件可以定义相同名称的函数，不会发生冲突

