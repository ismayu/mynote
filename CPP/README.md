**this指针**

每个成员函数都有一个隐含的输入参数this指针，this指向当前对象，this指针可以用来访问对象的数据成员。成员函数是属于类的，成员数据是属于对象的

static成员函数没有默认将this指针参数，所以static成员无法访问对象的数据，只能访问static数据成员。

this指针是动态构造的，只有在调用非静态成员函数时，才临时构造并传入到成员函数的形参中，调用完毕则被销毁（与形参的属性一致），这就是平时并不占用对象的内存的原因。

在虚函数所在类中，有一张虚函数表，而类的对象则有一个虚表指针，指向这张虚表。**当虚函数被子类的函数覆盖（重写）时，虚函数表中的相应位置的函数指针将被替换成子类的函数指针**



在Visual C++中，对象数据指针地址是用ecx寄存器来传递的。也就是说，在类方法中，对对象数据的访问，是使用ecx寄存器中的数值来作为对象基址指针对对象数据进行存取等操作

在linux x64架构下gcc编译this放在**rdi**寄存器内，作为第一个参数传给非static的类成员函数%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。

超过7个参数，直接放到栈内

this指针的类型是 类类型* const，是常量指针，它的值不能被修改

用this->或者(*this).去访问成员变量或函数

**命名规范**

https://www.cnblogs.com/winslam/p/11147396.html

**函数参数传递方式：**

32位程序使用栈传递

64位程序根据参数的个数而不同

参数1~6个，使用寄存器传递 rdi rsi rdx rcx r8 r9

参数大于6个，多出来的参数使用栈传递

**setjmp()函数与longjmp()函数 实现重入**

setjmp是C标准库中提供的一个函数，它的作用是保存程序当前运行的一些状态。它的函数原型如下：

int setjmp( jmp_buf env );

setjmp函数用于保存程序的运行时的堆栈环境，接下来的其它地方，你可以通过调用longjmp函数来恢复先前被保存的程序堆栈环境。当setjmp和longjmp组合一起使用时，它们能提供一种在程序中实现“非本地局部跳转”（"non-local goto"）的机制。并且这种机制常常被用于来实现，把程序的控制流传递到错误处理模块之中；或者程序中不采用正常的返回（return）语句，或函数的正常调用等方法，而使程序能被恢复到先前的一个调用例程（也即函数）中。

对setjmp函数的调用时，会保存程序当前的堆栈环境到env参数中；接下来调用longjmp时，会根据这个曾经保存的变量来恢复先前的环境，并且当前的程序控制流，会因此而返回到先前调用setjmp时的程序执行点。此时，在接下来的控制流的例程中，所能访问的所有的变量（除寄存器类型的变量以外），包含了longjmp函数调用时，所拥有的变量。

longjmp也是C标准库中提供的一个函数，它的作用是用于恢复程序执行的堆栈环境，它的函数原型如下：

void longjmp( jmp_buf env, int value );

backtrace可以获取堆栈信息

**符号表：**

readelf –s 读取符号表

![image-20211217101320103](C:\Users\mayu.colin\AppData\Roaming\Typora\typora-user-images\image-20211217101320103.png)

`type`: `object/func/section`

`bind`:` local/global static/const修饰对外不可见 local`

名字  const/static会加入前缀和-c/-s标志，函数返回值不在名字中体现，extern c修饰的额函数名字中不包含参数类型。const数据类型为只读

**extern "C"**

如果Add(int a, int b)是在c语言编译器编译，而在c++文件使用，则需要在c++文件中声明：extern "C" Add(int a, int b)，因为c编译器和c++编译器对函数名的解释不一样（c++编译器解释函数名的时候要考虑函数参数，这样是了方便函数重载，而在c语言中不存在函数重载的问题），使用extern "C"，实质就是告诉c++编译器，该函数是c库里面的函数。如果不使用extern "C"则会出现链接错误。符号表中不会加入类型

**c++标准异常**

bad_typeid、bad_cast、bad_alloc、ios_base::failure、out_of_range 都是 exception 类的派生类。C++ 程序在碰到某些异常时，即使程序中没有写 throw 语句，也会自动拋出上述异常类的对象。这些异常类还都有名为 what() 的成员函数，返回字符串形式的异常描述信息。使用这些异常类需要包含头文件 stdexcept。

**main函数参数**

main( int argc, char* argv[], char **env )

第一个参数，int型的argc，为整型，用来统计程序运行时发送给main函数的命令行参数的个数，在VS中默认值为1，gcc中默认值为1 

第二个参数，char*型的argv[]，为字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。

各成员含义如下： 

  argv[0]指向程序运行的全路径名

  argv[1]指向在DOS命令行中执行程序名后的第一个字符串 

  argv[2]指向执行程序名后的第二个字符串 

  argv[3]指向执行程序名后的第三个字符串 

   argv[argc]为NULL 

第三个参数，char**型的env，为字符串数组。env[]的每一个元素都包含ENVVAR=value形式的字符串，其中ENVVAR为环境变量，value为其对应的值。平时使用到的比较少。

 

 

**函数签名**（Function Signature），函数签名包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息。函数签名用于识别不同的函数，就像签名用于识别不同的人一样，函数的名字只是函数签名的一部分

 

ANSI C标准中有几个标准预定义宏（也是常用的）：

__LINE__：在源代码中插入当前源代码行号；

__FILE__：在源文件中插入当前源文件名；

__DATE__：在源文件中插入当前的编译日期

__TIME__：在源文件中插入当前编译时间；

__STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；

__cplusplus：当编写C++程序时该标识符被定义。

**宏**

```c++
#define MY_PRINTF(…) printf(__VA_ARGS__) 
```

\\符号:换行符

"##"符号:在可变参数的个数为0时，消除参数前面的逗号

```c++
#define MY_PRINTF(fs, …) printf(fs, ##__VA_ARGS__) 
```

\##作为连接符

```c++
#define Concatenator(a, b) a##b
```

Concatenator(12, 34) 替换成 “1234”

\#@x 符号

给x加上单引号，结果返回是一个const char

"#"符号

"#"符号的作用是“字符化”代码 给参数加双引号

```c++
#define ToString(s) #s  //将参数s字符串化
```

`ToString(123)` 返回 `“123”`

**C++ 反射**

https://blog.csdn.net/y1196645376/article/details/51455273

反射功能

通过名字创建类

枚举所有member

获取member的name和type

能够get/set　member

序列化/反序列化 

**模板实例化**

http://www.cnblogs.com/assemble8086/archive/2011/10/02/2198308.html

会实例化的情况：

- 在我们使用类模板时，只有当代码中**使用**了类模板的一个实例的名字，而且上下文环境要求必须存在类的定义时，这个类模板才被实例化。
- 定义一个类类型的对象时需要该类的定义，因此类模板会被实例化。
- 在使用sizeof()时，它是计算对象的大小，编译器必须根据类型将其实例化出来，所以类模板被实例化.
- new表达式要求类模板被实例化。
- 引用类模板的成员会导致类模板被编译器实例化。

不会实例化的情况：

- 声明一个类模板的指针和引用，不会引起类模板的实例化，因为没有必要知道该类的定义。

需要注意的是，类模板的成员函数本身也是一个模板。标准C++要求这样的成员函数只有在被调用或者取地址的时候，才被实例化。用来实例化成员函数的类型，就是其成员函数要调用的那个类对象的类型

**函数指针**

定义：

函数返回值类型 (* 指针变量名) (函数参数列表);

```c++
int(*pf)(int, int); //定义一个函数指针

typedef int (* FuncName)(int ,int) //宏定义

FuncName f; //定义一个函数指针
```

两种用法

```c++
FuncName NormalFunc1 = signal_fun;
NormalFunc1(100);
FuncName NormalFunc2 = &signal_fun;
(*NormalFunc2)(101);
```

指向类成员函数的指针

```c++
typedef int (CUp::*(UPMEMBERFUNC))(int);  //宏定义 里面的括号用不用都可以
void (X::* pmf)(int);  //定义一个指向类X的返回void值，参数为 int的指针
pmf = &X::f;      //类成员函数指针变量pmf被类成员函数f赋值
X *p;
P = new X();
p->*pmf(100); //调用类成员函数f
```

指向函数成员变量的指针

```c++
typedef int CUp::*(UPMEMBER); // 宏定义 用不用括号都可以
T C::* pmbr // 【指向类C的T类型数据成员的指针】。
// 其合法值是每个 &C::m 和 nullptr，其中 m 是类/结构体 C 的 T 类型的非静态数据成员。

struct C { int foo; int bar; };
C valc;
int C::*pIntmbr = nullptr; // 申明一个指向C类类成员的int指针
pIntMbr = &C::foo; // 或者 pIntMbr =&C::bar;
valc::* pIntMbr =999;
```

**不定参数**

```C++
va_list ap;
va_start(ap, argcount) // 初始化一个va_list的变量ap
va_arg(ap, type) // 获取下一个type类型的参数
va_end(ap) // 结束使用ap
```

**static**

符号表中会加一个前缀，并且类型为local不是global，对外不可见  显示加上_s标志

static成员变量不占用类的内存空间，分配在数据区(.data)

静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。所以需要在cpp里面进行定义。static在单例模式中有一个运用

###### 1.static 全局变量和普通的全局变量有什么区别

存储方式都是在常量区

普通全局变量：在各个源文件中都有效

若要在多个cpp文件中使用全局变量，不可以声明在头文件中，会有重复定义错误

普通类型的全局变量

```c++
// （1）a.c文件
unsigned char key;
//（2）b.c文件：
extern unsigned char key;
```

自定义类型的全局变量

```c++
// 在a.h中声明
struct mystruct
{ int intValue; };
// a.cpp中定义
#include a.h
mystruct mystvalue;
// b.cpp中
#include a.h
extern mystruct mystvalue;
```

static全局变量：只在定义该变量的源文件中有效。

这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以

**如果定义在头文件中，每个include头文件的cpp都包含一个该变量的副本，在头文件中定义static变量会造成变量多次定义，造成内存空间的浪费，而且也不是真正的全局变量。应该避免使用这种定义方式。**

###### 2.static局部变量和普通的局部变量的区别？

​	生命周期不同，static只初始化一次，下一次依据上一次的结果值，作用域还是局部变量的作用域，但是生存周期将直到程序退出。

###### 3.static函数和普通函数的区别？

在内存中都只有一份;

在函数的返回类型前加上关键字static，函数就被定义成为静态函数。

**普通 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用**。因此定义静态函数有以下好处：

<1> 其他文件中可以定义相同名字的函数，不会发生冲突。

<2> 静态函数不能被其他文件所用。

###### 4 static静态成员函数和普通成员函数

普通成员函数在参数传递时编译器会隐藏地传递一个this指针.通过this指针来确定调用类产生的哪个对象;但是静态成员函数没有this指针,不知道应该访问哪个对象中的数据,所以在程序中不可以用静态成员函数访问类中的普通变量

静态成员函数调用：A:: s_fun(); objA.s_fun(); 静态成员函数可以通过类名或对象名来调用

不具有this指针，因而自然不能声明为const。

静态数据成员和普通数据成员一样遵从public,protected,private访问规则；

###### 5.静态成员变量和普通成员变量

(1)静态成员变量的初始化

静态成员不属于类的任何对象，所以并不是对象建立时被定义的，所以它不能由类的构造函数初始化，一般也不能在类内初始化。

关键字static只出现类的内部。

1、在类外定义且初始化

2、常量静态成员可以在类内初始化

一般来说无论怎样静态成员变量都需要在类外进行定义（定义可以初始化赋值，如果不显示初始化就是默认初始化）

int A::ac=1;  //类外定义且初始化

(2)静态成员变量的访问

1、使用类作用域运算符直接访问

2、使用类的对象访问

3、成员函数可以直接访问

```C++
a.ac;  //使用类的对象访问
A::bc; //类作用域运算符直接访问
```

静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性

**const**

符号表中会加一个前缀，并且类型为local而不是global，对外不可见 显示加上**_c**标志

const定义的全局变量不能被其他文件访问,必须加extern 才能被连接.(注意是 cc 文件中,不能在 .h 文件..h 文件会被展开)

1. 在C++中，只有被声明为const的成员函数才能被一个const类对象调用 （const类才能调用const成员函数）
2.  const成员函数可以被对应的具有相同形参列表的非const成员函数重载
3. 成员函数的后面加上const关键字时，隐式的将this指针修改为 const Screen *const 即指向类类型常量版本的常量指针。const指针修饰的是被隐藏的this指针所指向的内存空间，修饰的是this指针，所以不能修改类的成员变量
4. const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；
5. 在C++中，const成员变量也不能在类定义处初始化，**只能通过构造函数初始化列表进行**，并且必须有构造函数。const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么

```C++
// 注意const修饰的是变量还是指针
const int * a4 = &a1;  ///const data,non-const pointer
int * const a5 = &a1;  ///non-const data,const pointer
```

**内存申请**

`void * malloc(int n);`

n：申请空间大小（单个类型大小*总个数）

通过malloc函数得到的堆内存必须使用memset函数来初始化

`void *calloc(int n,int size);`

注意：最后申请空间大小为： n和size相乘

calloc函数得到的内存空间是经过初始化的，其内容全为0。calloc函数适合为数组申请空间，可以将size设置为数组元素的空间长度，将n设置为数组的容量

`void * realloc(void * p,int n);`

如果n小于或等于p之前指向的空间大小，那么。保持原有状态不变。如果n大于原来p之前指向的空间大小，那么，系统将重新为p从堆上分配一块大小为n的内存空间，同时，将原来指向空间的内容依次复制到新的内存空间上，p之前指向的空间被释放, **relloc函数分配的空间是未初始化的**

`void * alloca(size_t)`

此函数可以在栈上分配内存 使用时当心出现野指针

**volatile**
易变的，每次使用时都是从内存中读取, 用于处理 MMIO(Memory-mapped I/O) 带来的问题，在引入 MMIO 之后，一块内存地址既有可能是真正的内存，也有可能是映射的一个I/O端口。因此，读/写一个内存地址，既有可能是真正地操作内存，也有可能是读/写一个I/O设备
https://blog.csdn.net/liitdar/article/details/86063883
跟锁不是一回事

可见性 只要有修改，就会体现在内存中

使用 volatile 关键字声明的变量具有三种特性：易变的、不可优化的、顺序执行的
1 不会在两个操作之间把volatile变量缓存在寄存器中。在多任务、中断、甚至setjmp环境下，变量可能被其他的程序改变，编译器自己无法知道，volatile就是告诉编译器这种情况。
2 不做常量合并、常量传播等优化

![image-20211217101506641](C:\Users\mayu.colin\AppData\Roaming\Typora\typora-user-images\image-20211217101506641.png)  

不会把if为真处理
3 对volatile变量的读写不会被优化掉。如果你对一个变量赋值但后面没用到，编译器常常可以省略那个赋值操作，然而对Memory Mapped IO的处理是不能这样优化的。

**restrict**

只修饰指针，只允许用这个指针来操作对应数据，不可以用其他的指针或者变量或者其他方式

**typeid**

此操作符的返回类型是type_info的标准库类型的引用 
该类的拷贝构造函数以及赋值操作符被定义为private，这是禁止复制该类型的对象。创建type_info对象的唯一方法，便是调用typeid操作符

```C++
int iVal;
cout << typeid(iVal).name() << endl;
cout << typeid(int).name() << endl;
```

当typeid操作符的操作数是不带有虚函数的类类型时，typeid操作符会指出操作数的类型，而不是底层对象的类型。也就是说如果类没有写虚函数，typeid返回的就是实际上看到的类型

**delete**

delete一个指针时，务必保证该指针的当前类型就是其定义的类型 ,`delete  void*`  **将不会调用析构函数**

memset 的使用，内部不能存在复杂数据结构

**虚继承**

虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：

其一，浪费存储空间；

第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。

   ![image-20211217101528176](C:\Users\mayu.colin\AppData\Roaming\Typora\typora-user-images\image-20211217101528176.png)

![image-20211217101537686](C:\Users\mayu.colin\AppData\Roaming\Typora\typora-user-images\image-20211217101537686.png)

```c++
class A //大小为4
{
public:
	int a;
};
class B :virtual public A //大小为12，变量a,b共8字节，虚基类表指针4
{
public:
	int b;
};

class C :virtual public A //与B一样12
{
public:
	int c;
};
class D :public B, public C //24,变量a,b,c,d共16，B的虚基类指针4，C的虚基类指针4
{
public:
	int d;
}; 
```

**Operator 用法**

操作隐式转换

```c++
#include <iostream>
using namespace;
class A
{
public:
	explicit A(int a):m_a(a){}
	operator int()
	{
		return 5*m_a;
	}
private:
	int m_a;
};
int main
{
	A _a(1);
	int b = _a;
	cout << "_a:" << _a <<endl;
	cout << "b:" << b << endl;
    return 0;
}
```

其中b=_a调用了`operator int `隐式类型转换，也可使用模板 这样可以转换成任意类型,比如nullptr_t的实现

操作符重载

```c++
Test &operator ++(); //前增量
Test &operator ++(int);//后增量
```

**notice**

1.malloc不能调用构造函数  new可以，new和delete是运算符，而malloc和free是标准库函数，delete可以调用析构函数，而free不可。

2.指针数组和数组指针

int *  a[4]：是指a数组里面的元素都是指针 * 修饰int []运算符优先级大于 * 所以是个数组，（里面为四个int指针）

int (*a)[4]：是指a是个指针，指向长度为4的数组。 *修饰a ()优先级大于[] 所以受限是个指针，然后再指向数组                                                 

3.不能重载的运算符：`?:, *, .*, ::, . `   

.* 用于调用指针指向的函数或者变量

4.多态由虚函数构成，多态只能通过指针和引用完成。

纯虚函数是特殊的虚函数用来规范子类的行为，在子类中必须实现或者也声明为虚函数；

抽象类是含一个或多个的纯虚函数的类，抽象类声明指针不能声明变量；

接口是其所有的成员函数都为纯虚函数。

5.一个inline member function躯体之内的一个 data member 绑定操作会在整个class声明完成后才发生。

6.(cast)转型操作并不改变指针所含的真正地址，只影响“被指出之内存的大小和内容”的解释方式。

7.构造函数的初始化列表的初始化顺序是根据成员变量的声明循序来执行的。

8.class A{ const int  size = 0; };错，常量必须在构造函数的初始化列表中初始化，或将其设置为static。 实际会分配空间，并且设为只读

9.静态绑定和动态绑定

只有虚函数才使用动态绑定，其他都是静态绑定。

10.析构函数可以使virtual 型，而构造函数则不能，为什么？

虚函数采用一种虚调用的方法，虚调用是一种可以在只有部分信息的情况下工作的机制，特别允许我们调用一个只知道其接口而不知道其准确对象类型的函数，如果要创建一个对象，势必要知道对象的准确类型，因此构造行数不能为虚函数。

11.析构函数可以是内联函数。

12.explicit 关键字可以消除隐式转换，用该关键字修饰构造函数

13.多态指针的一致是指“子类虚函数返回的静态类型是父类虚函数所返回的多态指针的动态类型集合中的某个类型”。

14.系统自带的头文件用尖括号括起来，这样编译器会在系统文件目录下查找。

用户自定义的文件用双引号括起来，编译器会先在用户目录下查找，然后到c++安装目录下查找，最后在系统文件中查找。

15.智能指针：防止程序员忘记delete出的对象，而造成内存泄漏。

std::auto_ptr:属于STL也在namespace std中，#include<memory>即可使用，智能处理单个对象，不能处理对象数组。

boost::shared_ptr属于boost库，#include<boost/smart_ptr.hpp>即可使用，也用于处理单个对象。

boost::scoped_ptr是处理对象数组。

16.进程与线程的区别？

线程是指进程内的一个执行单元，也是进程内的可调度实体。

区别：

（1）调度：线程作为调度最小单元，进程是资源分配的最小单元。

（2）并发性：不仅进程间可以并发执行，一个进程中的多个线程间也可以并发执行。

（3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。

（4）系统开销：在创建和撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤销进程的开销。

17.数组名作为参数传递时退化为指针

18.RTTI（Run-Time type Identitification ）通过运行时类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际源生类型（dynamic_cast，typeid）。

19.指针和引用的区别：

1）指针是一个变量，里面存放的是地址，引用是变量本身。

2）引用在声明时必须初始化，且不能再改变。

3）指针初始化可以为空，且可以改变其值

4）指针可有多级，引用只有一级（**p合法，&&r不合法(c11引入右值引用)）

5）可以有const指针没有const引用  引用const表示指向的内容不可更改

6）指针和引用++的意义不同

7）作为参数传递时，引用传递的是变量本身，指针传递的是地址。

\8) 引用是通过指针实现的，所以也会占用内存空间，对引用取地址被编译器解释为对引用的对象取地址，所以取到的地址是引用指向对象的地址

**&**

1）引用在赋值=的左边，而取地址在赋值的右边

2）和类型在一起的是引用，和变量在一起的是取址

20.静态成员函数不能直接调用非静态成员变量，不能定义为const因为const是对this指针加以修饰，但static却不用this指针。

21.常见的四种类型转换关键字：

static_cast：两个类型之间相关，例如整形之间就是这种转换。不能用语指针之间的转换int* char*等

const_cast：消除类型的const性质

reinterpret_cast：两个类型之间不相关，例如指针和int型的转换。

dynamic_cast：动态类型转换。

22.c++标准中不允许copy构造函数传值参数：因为就会造成copy构造函数中调用copy构造函数，就造成死循环。

23

strlen(char *str) : 求字符串长度

strcpy(char *dest, char *src) : 把src拷贝到dest

strcat(char *dest, char *src) : 把src连接到dest后面

strcmp(char *s1, char *s2) : 按照各个字符（ascii）比较s1和s2,相等则返回0,否则返回ascii相减的结果

strstr(char *s1, char *s2) : 在s1中查找s2,返回找到的位置,若找不到则返回NULL

27.为节省内存，c++将常量字符串放在单独的一个内存区域，当有几个指针赋值相同的字符串常量时，指向的是同一个地址。但是常量内存初始化数组是分配的新空间，是把常量拷贝过来。

28.当类中含有const，reference时，基类的任何一个构造函数都必须有初始化列表。

29.c++不是类型安全的，因为可以进行强制类型转换（reinterpret）。

30.s[10]，s和&s的值是一样的，但是两个代表的意思不同，前者表示的是数组的第一个地址，而&s表示的是整个数组。

31.栈中存放的是，局部变量，返回地址，参数，自动变量。堆中存放的是new出来的对象，全局变量，静态变量等。

32.仿函数：另名函数对象就是一个算法函数，可以生成对象作为一个函数的参数；例如sort（iter.begin(),iter.end(),greater<int>()）;其中greater<int>()是仿函数;STL中的仿函数分类：若以操作数个数划分可分为一元和二元仿函数，若以功能划分可分为算术运算，关系运算，逻辑运算三大类。

33.什么时候需要定义拷贝构造函数：

（1）数据成员有指针 ；

（2）类数据成员管理资源；

35.char c[] :分配的是一个局部数组；char* c：分配的是一个全局数组，内存在全局区域。 

36.

int (*A)[10] ()的优先级大于[ ] ，因此首先它是一个指针，它指向一个数组，数组的维数是10.因此数组指针也称为行指针，它的度数是一行一行的。

int * A[10] [ ]的优先级大于*，因此它是一个维数为三的数组，里面存放的是指向int的指针。 

37：函数指针：

double  (*f)():  f是一个指针，指向一个没有参数且返回double 的函数；

double  （*f[10]）()，f是一个数组，f有十个元素，元素都是函数指针，指向的函数类型是没有参数返回double的函数；[]优先级大于*

double  (*(*f)(int,int))(int)：f是一个函数指针，指向的函数是由两个int参数并返回一个函数指针的函数，返回的函数指针指向有一个int参数且返回int的函数。 

38.非法指针：不仅指指向未分配的内存，还包括已经不能访问的内存，例如：指向已经返回的局部变量，越过数组边界的地址。 

39.c语言中的未定义行为：是指c语言标准未作出规定的行为。例如：

  1>同一运算符中多个函数的操作数的计算顺序。int x=f()+g();如果g()中调用了f()，则两个操作数的执行顺序就会对结果有影响；

  2>函数各参数的求值顺序，同上例类似；

  3>通过指针直接修改const的值。 

43.http字段的含义？ 

44.初始化列表必须初始化：const成员，基类构造函数，引用。 static不用初始化，因为他不是对象成员。引用需要在初始化列表进行初始化 

45.函数模板的实例化是由编译程序在处理函数调用时自动完成的；类模板的实例化必须由程序员在程序中显示的给出；函数模板仅针对函数类型不同的函数；类模板仅针对数据成员和函数成员类型不同的类； 

46.批处理不能处理交互式的作业。 

47.数据的逻辑结构有两个元素：一是数据元素的集合，用D表示，二是D上的关系，它反映D中元素的前后件关系，通常记为R，即一个数据结构可以表示成B=(D,R);为了反映B中元素的前后件关系，通常用二元组表示，例如，假设 a 与 b 是 D 中的两个数据，则二元组（ a,b ）表示 a 是 b 的前件， b 是 a 的后件。 如果一个非空的数据结构满足下列两个条件：①有且只有一个根结点；②每一个结点最多有一个前件，也最多有一个后件。则称该数据结构为线性结构。 

48.引入页式内存分配的动力是改善内存利用率，段式内存是为了满足用户需要，那么应该是引入多道序程序提高系统利用率，而基于段页式不连续的内存分配的交换技术更好地满足了多道程序的运行需要。 

49._cdecl __fastcall与__stdcall，三者都是调用约定(Calling convention)，它决定以下内容：1)函数参数的压栈顺序，2)由调用者还是被调用者把参数弹出栈，3)以及产生函数修饰名的方法。 关键字 __stdcall、__cdecl和__fastcall可以直接加在要输出的函数前，也可以在编译环境的Setting.../C/C++ /Code Generation项选择。当加在输出函数前的关键字与编译环境中的选择不同时，直接加在输出函数前的关键字有效。它们对应的命令行参数分别为/Gz、 /Gd和/Gr。缺省状态为/Gd，即__cdecl

1>__stdcall调用约定：函数的参数自右向左通过栈传递，被调用的函数在返回前清理传送参数的内存栈。

2>_cdecl是C和C++程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用_stdcall函数的大。函数采用从右到左的压栈方式。注意：对于可变参数的成员函数，始终使用__cdecl的转换方式。

3>__fastcall调用约定：它是通过寄存器来传送参数的（实际上，它用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈）。

4>thiscall仅仅应用于"C++"成员函数。this指针存放于CX寄存器，参数从右到左压。thiscall不是关键词，因此不能被程序员指定。

5>nakedcall采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。naked call不产生这样的代码。naked call不是类型修饰符，故必须和_declspec共同使用。

_beginthread需要__cdecl的线程函数地址，_beginthreadex和CreateThread需要__stdcall的线程函数地址。

6、DLLMain负责初始化(Initialization)和结束 (Termination)工作，每当一个新的进程或者该进程的新的线程访问DLL时，或者访问DLL的每一个进程或者线程不再使用DLL或者结束时，都会调用DLLMain。但是，使用TerminateProcess或TerminateThread结束进程或者线程，不会调用DLLMain。 

7、一个DLL在内存中只有一个实例

DLL程序和调用其输出函数的程序的关系：

1)、DLL与进程、线程之间的关系

DLL模块被映射到调用它的进程的虚拟地址空间。

DLL使用的内存从调用进程的虚拟地址空间分配，只能被该进程的线程所访问。

DLL的句柄可以被调用进程使用；调用进程的句柄可以被DLL使用。

DLL可以有自己的数据段，但没有自己的堆栈，使用调用进程的栈，与调用它的应用程序相同的堆栈模式。

**内联函数和宏**

1.内联函数可以在编译期间完成诸如类型检测，语句是否正确等编译功能；宏 就 不具有这样的功能。

\2. 宏是单纯的文本预处理替换，inline是编译器优化提示（注意只是提示，并不保证内联）。 inline 保证内联后和调用函数获得相同的结果，而宏 —— 它什么都不保证。

3.宏由于算符优先级很容易出问题，不易检查；用内联则不可。

4.内联一般结构简单，不包括循环处理和判断之类复杂结构（即使声明为inline也会被编译器优化）；宏定义里则可以定义成复杂的结构，如果 你能保证不出错的话。

**union**

联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式

大端 低地址存高位 按顺序存储  小端相反
